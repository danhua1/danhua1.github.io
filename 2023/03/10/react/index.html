<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="react 学习"><meta name="keywords" content="文档,react"><meta name="author" content="sunshine"><meta name="copyright" content="sunshine"><title>react 学习 | 繁华落尽</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#state-amp-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">state&amp;生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#state%E7%9A%84%E6%9B%B4%E6%96%B0%E4%BC%9A%E8%A2%AB%E5%90%88%E5%B9%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">state的更新会被合并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8-amp-key"><span class="toc-number">1.3.</span> <span class="toc-text">列表&amp;key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95"><span class="toc-number">1.4.</span> <span class="toc-text">表单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">受控组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%A9%BA%E5%80%BC"><span class="toc-number">1.4.2.</span> <span class="toc-text">受控组件空值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87"><span class="toc-number">1.5.</span> <span class="toc-text">状态提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">1.6.</span> <span class="toc-text">组合和继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%8C%85%E5%90%AB"><span class="toc-number">1.6.1.</span> <span class="toc-text">直接包含</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%BA%90"><span class="toc-number">1.6.2.</span> <span class="toc-text">存在多个源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%8C%87%E5%BC%95"><span class="toc-number">2.</span> <span class="toc-text">高级指引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%9A%9C%E7%A2%8D"><span class="toc-number">2.1.</span> <span class="toc-text">无障碍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2"><span class="toc-number">2.2.</span> <span class="toc-text">代码分割</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React-lazy"><span class="toc-number">2.2.1.</span> <span class="toc-text">React.lazy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E8%BE%B9%E7%95%8C"><span class="toc-number">2.2.2.</span> <span class="toc-text">异常捕获边界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#content"><span class="toc-number">2.3.</span> <span class="toc-text">content</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#content%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.1.</span> <span class="toc-text">content使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E6%BB%A5%E7%94%A8content"><span class="toc-number">2.3.2.</span> <span class="toc-text">不要滥用content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-number">2.3.3.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Provider"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">Provider</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref%E8%BD%AC%E5%8F%91"><span class="toc-number">2.4.</span> <span class="toc-text">ref转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">2.5.</span> <span class="toc-text">高阶组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5jsx"><span class="toc-number">2.6.</span> <span class="toc-text">深入jsx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E9%A6%96%E5%AD%97%E6%AF%8D%E8%A6%81%E5%A4%A7%E5%86%99"><span class="toc-number">2.6.1.</span> <span class="toc-text">用户自定义的组件，首字母要大写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%80%89%E6%8B%A9%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.2.</span> <span class="toc-text">在运行时选择类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E4%B8%BA%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-number">2.6.3.</span> <span class="toc-text">JavaScript 表达式作为子元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-number">2.6.4.</span> <span class="toc-text">函数作为子元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E3%80%81Null-%E4%BB%A5%E5%8F%8A-Undefined-%E5%B0%86%E4%BC%9A%E5%BF%BD%E7%95%A5"><span class="toc-number">2.6.5.</span> <span class="toc-text">布尔类型、Null 以及 Undefined 将会忽略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%B0%83"><span class="toc-number">2.7.</span> <span class="toc-text">协调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8A%A8%E5%8A%9B"><span class="toc-number">2.7.1.</span> <span class="toc-text">设计动力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#diff-%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.2.</span> <span class="toc-text">diff 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">比对不同类型的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E5%AF%B9%E7%9B%B8%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">比对相同类型的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E5%AD%90%E8%8A%82%E7%82%B9%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">对子节点进行递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Keys"><span class="toc-number">2.7.2.4.</span> <span class="toc-text">Keys</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Refs-and-the-DOM"><span class="toc-number">2.8.</span> <span class="toc-text">Refs and the DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-Refs"><span class="toc-number">2.8.1.</span> <span class="toc-text">访问 Refs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-Props"><span class="toc-number">2.9.</span> <span class="toc-text">Render Props</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-PropTypes-%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">2.10.</span> <span class="toc-text">使用 PropTypes 进行类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">2.11.</span> <span class="toc-text">非受控组件</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">sunshine</div><div class="author-info__description text-center">我希望有个如你一般的人，如山间清爽的风，如古城温暖的光，从清晨到夜晚，由山间到书房，只要最后是你，就好。-----《从你的全世界路过》</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://autoload.github.io/css/images/banner_sky.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">繁华落尽</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">总览</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">react 学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/react/">react</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/react/react%E6%96%87%E6%A1%A3/">react文档</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="state-amp-生命周期"><a href="#state-amp-生命周期" class="headerlink" title="state&amp;生命周期"></a>state&amp;生命周期</h3><h4 id="state的更新会被合并"><a href="#state的更新会被合并" class="headerlink" title="state的更新会被合并"></a>state的更新会被合并</h4><p>当你调用  &gt;setState() 的时候,React 会把你提供的对象合并到当前的 state。</p>
<p>例如，你的 state 包含几个独立的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">    posts: [],</span><br><span class="line">    comments: []</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后你可以分别调用 setState() 来单独地更新它们：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">   fetchPosts().then(response =&gt; &#123;</span><br><span class="line">     this.setState(&#123;</span><br><span class="line">       posts: response.posts</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   fetchComments().then(response =&gt; &#123;</span><br><span class="line">     this.setState(&#123;</span><br><span class="line">       comments: response.comments</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里的合并是浅合并，所以 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>避免在父传子的时候 函数使用箭头函数，因为这样的话，每次渲染都会生成一个新的函数，会导致子组件重复渲染，可能实际上并不需要渲染。</p>
<h3 id="列表-amp-key"><a href="#列表-amp-key" class="headerlink" title="列表&amp;key"></a>列表&amp;key</h3><p>避免使用index作为组件的唯一key值<br>元素的key 只有放在就近数组的上下文中才会有意义。就是key需要放到循环组件的最外层，放置在内层没有多大意义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ListItem(props) &#123;</span><br><span class="line">  const value = props.value;</span><br><span class="line">  return (</span><br><span class="line">    // 错误！你不需要在这里指定 key：</span><br><span class="line">    &lt;li key=&#123;value.toString()&#125;&gt;</span><br><span class="line">      &#123;value&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    // 错误！元素的 key 应该在这里指定：</span><br><span class="line">    &lt;ListItem value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>key 只是在兄弟组件中需要唯一。但是在全局当中，可以存在相同的key<br>如果一个map中嵌套了多个层级，可以考虑把逻辑给提取出来，减少复杂性。</p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>组件整体来说可以分为两种：</p>
<ol>
<li>受控组件</li>
<li>非受控组件</li>
</ol>
<h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>受控和非受控，主要是看组件对应的vaule，是不是由开发者自己控制。<br>比如一个input组件，你输入的时候就能看到输入的值。那我可不可以把显示的值由我控制，进行组装后再由页面显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &#x27;&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">          &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上面的事例所展示，input显示是由onChange 事件来控制的，由开发者给value赋值，展示给用户看的。<br>这样的方式就叫受控组件，组件可以由你自由修改。</p>
<h4 id="受控组件空值"><a href="#受控组件空值" class="headerlink" title="受控组件空值"></a>受控组件空值</h4><p>当一个受控组件传递了vaule，但是并没有相对应的处理逻辑的时候，那么受控组件是无法编辑的。如果你发现了可以编辑，那么可能是你传递的vaule为null或者undefined的</p>
<h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>主要就是共用的状态可以提升到共同的父组件，由父组件进行分发，可以在usecontent中体现。</p>
<h3 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h3><h4 id="直接包含"><a href="#直接包含" class="headerlink" title="直接包含"></a>直接包含</h4><p> 自定义的组件，可能需要接受非本组件的内容，这时就可以使用children来接受外部的内容</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 父组件</span><br><span class="line">&lt;Test&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/Test&gt;</span><br><span class="line"></span><br><span class="line">子组件</span><br><span class="line"></span><br><span class="line"> const Test = (props:any) =&gt; &#123;</span><br><span class="line">    console.log(props)</span><br><span class="line">    const &#123; tabList, count,children,letf,right &#125; = props</span><br><span class="line">    console.log(children)</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line"></span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="存在多个源"><a href="#存在多个源" class="headerlink" title="存在多个源"></a>存在多个源</h4><p> 有可能外部内容来源并不是一个方向，可能有多个方向。这时候可以借助属性的方式来实现。就类似于vue的插槽属性</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 父组件</span><br><span class="line"></span><br><span class="line">  &lt;Test</span><br><span class="line">    letf=&#123;&lt;div&gt;123&lt;/div&gt;&#125;</span><br><span class="line">    right=&#123;&lt;div&gt;456&lt;/div&gt;&#125;</span><br><span class="line">  /&gt;</span><br><span class="line"></span><br><span class="line">子组件</span><br><span class="line"> const Test = (props:any) =&gt; &#123;</span><br><span class="line">    console.log(props)</span><br><span class="line">    const &#123; tabList, count,children,letf,right &#125; = props</span><br><span class="line">    console.log(children)</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        &#123;letf&#125;</span><br><span class="line">        &#123;right&#125;</span><br><span class="line"></span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="高级指引"><a href="#高级指引" class="headerlink" title="高级指引"></a>高级指引</h2><h3 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h3><p> 因为jsx组件最外层需要唯一一个根组件。但是有时候我们可能并不想要多添加一个div标签，于是Fragment 就应运而生，当空标签上面不存在任何的props的时候，我们也可以使用省略的写法&lt;&gt;&lt;&#x2F;&gt;</p>
<h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p> 现代的web技术，都是把多个文件打包成一个体积大的文件，这样一开始只要加载一个文件即可，避免一次性加载过多的文件，浏览器的http请求，同时只能存在6个，当6个满的话，后续的请求会等待，等待到前面有请求执行完毕后再继续执行，所以合并请求，代码合并也是前端性能优化的一个点。<br> 但是当一个包体积过大的时候，首屏的时间就会特别的长，这样对用户的体验感是非常差的，于是出现了很多模式，按照模块打包，每一个模块一个包。同时包加载的时候，使用懒加载的形式，也就是说：我只有用到了这个包才会进行加载，避免过多的加载数据。还有就是通过路由懒加载，每一个路由一个包，只有跳转到当前路由才会对包进行请求。</p>
<h4 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h4><p> React.lazy 和 Suspense 技术还不支持服务端渲染。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import React, &#123; Suspense &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const OtherComponent = React.lazy(() =&gt; import(&#x27;./OtherComponent&#x27;));</span><br><span class="line"></span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">        &lt;OtherComponent /&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> Suspense 是需要包裹在懒加载组件外部的。</p>
<h4 id="异常捕获边界"><a href="#异常捕获边界" class="headerlink" title="异常捕获边界"></a>异常捕获边界</h4><p> 当模块加载失败的，需要一个错误的页面来给用户进行反馈。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import React, &#123; Suspense &#125; from &#x27;react&#x27;;</span><br><span class="line">import MyErrorBoundary from &#x27;./MyErrorBoundary&#x27;;</span><br><span class="line"></span><br><span class="line">const OtherComponent = React.lazy(() =&gt; import(&#x27;./OtherComponent&#x27;));</span><br><span class="line">const AnotherComponent = React.lazy(() =&gt; import(&#x27;./AnotherComponent&#x27;));</span><br><span class="line"></span><br><span class="line">const MyComponent = () =&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyErrorBoundary&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">          &lt;OtherComponent /&gt;</span><br><span class="line">          &lt;AnotherComponent /&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/MyErrorBoundary&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><h4 id="content使用场景"><a href="#content使用场景" class="headerlink" title="content使用场景"></a>content使用场景</h4><p>  content 主要是用户多层级组件传递很少改动值所使用的。当多个子组件需要多个来源相同的数据的时候，可以考虑在他们共同的父组中获取数据，然后通过content进行向下分发数据，因为react数据流是自上向下的。</p>
<h4 id="不要滥用content"><a href="#不要滥用content" class="headerlink" title="不要滥用content"></a>不要滥用content</h4><p>  因为使用content 需要添加Provider，这样的话，子组件在当前的时候需要父组件传递对应的值，如果在别的地方需要别的来源的值，这样的话会存在冲突，也就是滥用的话会导致组件的复用性会变差很多的。所以看情况使用content。当发现使用content可能会导致组件复用性下降的时候，可以考虑组件组合的方式来实现具体业务。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><h5 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h5><p>多个Provider 组件是可以嵌套使用的，但是里层的数据会把外层的数据给覆盖掉。当Provider的vaule值发生变化的时候，那么内层的嵌套组件全都会重新进渲染</p>
<h3 id="ref转发"><a href="#ref转发" class="headerlink" title="ref转发"></a>ref转发</h3><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p> 组件是将props转化为页面，高阶组件是把组件转换成一个新的组件。也就是高阶组件就是参数为组件返回也是组件的一个函数。</p>
<p> HOC 不会修改原组件，也不会使用集成等方式来复制组件，只会把组件包装到一个新的容器中形成一个新的组件。HOC 是纯函数，没有副作用</p>
<h3 id="深入jsx"><a href="#深入jsx" class="headerlink" title="深入jsx"></a>深入jsx</h3><h4 id="用户自定义的组件，首字母要大写"><a href="#用户自定义的组件，首字母要大写" class="headerlink" title="用户自定义的组件，首字母要大写"></a>用户自定义的组件，首字母要大写</h4><p> 开头小写的元素代表的是内置的组件，比如<div></div>，但是首字母大写的话，会被当成一个自定义的组件，如 <Foo /> 会编译为 React.createElement(Foo)</p>
<h4 id="在运行时选择类型"><a href="#在运行时选择类型" class="headerlink" title="在运行时选择类型"></a>在运行时选择类型</h4><p> 你不能将通用表达式作为 React 元素类型。如果你想通过通用表达式来（动态）决定元素类型，你需要首先将它赋值给大写字母开头的变量。这通常用于根据 prop 来渲染不同组件的情况下:<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from &#x27;./stories&#x27;;</span><br><span class="line"></span><br><span class="line">const components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Story(props) &#123;</span><br><span class="line">  // 错误！JSX 类型不能是一个表达式。</span><br><span class="line">  return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 要解决这个问题, 需要首先将类型赋值给一个大写字母开头的变量：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from &#x27;./stories&#x27;;</span><br><span class="line"></span><br><span class="line">const components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Story(props) &#123;</span><br><span class="line">  // 正确！JSX 类型可以是大写字母开头的变量。</span><br><span class="line">  const SpecificStory = components[props.storyType];</span><br><span class="line">  return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="JavaScript-表达式作为子元素"><a href="#JavaScript-表达式作为子元素" class="headerlink" title="JavaScript 表达式作为子元素"></a>JavaScript 表达式作为子元素</h4><p> JavaScript 表达式可以被包裹在 {} 中作为子元素。例如，以下表达式是等价的：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;MyComponent&gt;foo&lt;/MyComponent&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent&gt;&#123;&#x27;foo&#x27;&#125;&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure></p>
<p> 这对于展示任意长度的列表非常有用。例如，渲染 HTML 列表：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function Item(props) &#123;</span><br><span class="line">  return &lt;li&gt;&#123;props.message&#125;&lt;/li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function TodoList() &#123;</span><br><span class="line">  const todos = [&#x27;finish doc&#x27;, &#x27;submit pr&#x27;, &#x27;nag dan to review&#x27;];</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 因为 if和for不算JavaScript的表达式，所以在子元素中无法使用。如果需要使用if for等逻辑，可以参考下面的函数作为子元素</p>
<h4 id="函数作为子元素"><a href="#函数作为子元素" class="headerlink" title="函数作为子元素"></a>函数作为子元素</h4><p> 通常，JSX 中的 JavaScript 表达式将会被计算为字符串、React 元素或者是列表。不过，props.children 和其他 prop 一样，它可以传递任意类型的数据，而不仅仅是 React 已知的可渲染类型。例如，如果你有一个自定义组件，你可以把回调函数作为 props.children 进行传递：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 调用子元素回调 numTimes 次，来重复生成组件</span><br><span class="line">function Repeat(props) &#123;</span><br><span class="line">  let items = [];</span><br><span class="line">  for (let i = 0; i &lt; props.numTimes; i++) &#123;</span><br><span class="line">    items.push(props.children(i));</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ListOfTenThings() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Repeat numTimes=&#123;10&#125;&gt;</span><br><span class="line">      &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125;</span><br><span class="line">    &lt;/Repeat&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="布尔类型、Null-以及-Undefined-将会忽略"><a href="#布尔类型、Null-以及-Undefined-将会忽略" class="headerlink" title="布尔类型、Null 以及 Undefined 将会忽略"></a>布尔类型、Null 以及 Undefined 将会忽略</h4><p> false, null, undefined, and true 是合法的子元素。但它们并不会被渲染。以下的 JSX 表达式渲染结果相同：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;false&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;null&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;true&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="协调"><a href="#协调" class="headerlink" title="协调"></a>协调</h3><h4 id="设计动力"><a href="#设计动力" class="headerlink" title="设计动力"></a>设计动力</h4><p>  每次调用render方法的时候，react内部都会生成一个新的元素组成的树。同时会比较元素树与上一次生成的是否有什么不一样的地方，如果有不一样的会进行更新操作。</p>
<h4 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h4><p>  当对比两颗元素树时，首先会比对根节点。不同类型的根节点会有不同的形态。</p>
<h5 id="比对不同类型的元素"><a href="#比对不同类型的元素" class="headerlink" title="比对不同类型的元素"></a>比对不同类型的元素</h5><p>  当更新后的元素类型与一开始的类型不一样的时候，那么会销毁掉原有的元素树，重新建立新的元素树。根节点下面的所有子元素也会一同销毁掉。</p>
<h5 id="比对相同类型的元素"><a href="#比对相同类型的元素" class="headerlink" title="比对相同类型的元素"></a>比对相同类型的元素</h5><p>  当前后的元素类型一致的时候，更新只会更新对应的props属性的值，style比较特殊一些，style只会更新内部变更的数据，并不会把所有的都更新掉。</p>
<h5 id="对子节点进行递归"><a href="#对子节点进行递归" class="headerlink" title="对子节点进行递归"></a>对子节点进行递归</h5><p>当递归子节点的时候，会默认同时检测两个子元素的列表，当两者不一样的时候会返回一个mutation。这样的话，也就是变更的话，最好是把变化的最加到更新最下面，这样更新的开销会比较小。如果放到开头的话，那么会导致每一项都会不一样的，每次比对都会生成mutation。开销会变大很多。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;third&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h5><p> 为了解决上面的元素增加位置存在的问题，react添加了key属性来解决。当元素中存在key属性的时候，元素发生更新时就会对比两者的key，以便于快速找到对应的key，如果没有找到对应的key那么就会新增一个元素。<br> key并不需要你在全局中是唯一的，只需要你在当前列表中是唯一的即可。<br> key不建议使用index下标来标识，因为如果当元素发生移动的时候，对比会产生问题。他的key会随着变化，会增加开销。</p>
<h3 id="Refs-and-the-DOM"><a href="#Refs-and-the-DOM" class="headerlink" title="Refs and the DOM"></a>Refs and the DOM</h3><h4 id="访问-Refs"><a href="#访问-Refs" class="headerlink" title="访问 Refs"></a>访问 Refs</h4><p>当 ref 被传递给 render 中的元素时，对该节点的引用可以在 ref 的 current 属性中被访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const node = this.myRef.current;</span><br></pre></td></tr></table></figure>
<p>ref 的值根据节点的类型而有所不同：</p>
<ol>
<li>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。</li>
<li>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。</li>
<li>你不能在函数组件上使用 ref 属性，因为他们没有实例。</li>
</ol>
<h3 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h3><p>render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Cat extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const mouse = this.props.mouse;</span><br><span class="line">    return (</span><br><span class="line">      &lt;img src=&quot;/cat.jpg&quot; style=&#123;&#123; position: &#x27;absolute&#x27;, left: mouse.x, top: mouse.y &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove = this.handleMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123;&#123; height: &#x27;100vh&#x27; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/*</span><br><span class="line">          Instead of providing a static representation of what &lt;Mouse&gt; renders,</span><br><span class="line">          use the `render` prop to dynamically determine what to render.</span><br><span class="line">        */&#125;</span><br><span class="line">        &#123;this.props.render(this.state)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Cat mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个和函数式组件中，子给父传值的时候是通过回调函数执行的，那么可以在回调的同时渲染组件来模拟实现render props</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import styles from &#x27;./index.less&#x27;;</span><br><span class="line"></span><br><span class="line">export default function IndexPage() &#123;</span><br><span class="line">  const test=(x,y)=&gt;&#123;</span><br><span class="line">    return &lt;p&gt;&#123;x,y&#125;&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div renderParent=&#123;test&#125;&gt;</span><br><span class="line">      &lt;h1 className=&#123;styles.title&#125;&gt;Page index&lt;/h1&gt;</span><br><span class="line">      &#123;test()&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用-PropTypes-进行类型检查"><a href="#使用-PropTypes-进行类型检查" class="headerlink" title="使用 PropTypes 进行类型检查"></a>使用 PropTypes 进行类型检查</h3><p>现有的项目可以使用ts interface来替代。</p>
<h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>受控组件、非受控组将，常见于form表单中，所有的数据控制交于表单控制的组件称之为非受控组件。如果一个组件，赋值以及onchange方法是由程序控制的话，那么这个组件就是受控组件。<br>经典的非受控组件就是 input file组件，这个只能由用户进行控制。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">sunshine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://danhua1.github.io/2023/03/10/react/">https://danhua1.github.io/2023/03/10/react/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://danhua1.github.io">繁华落尽</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%96%87%E6%A1%A3/">文档</a><a class="post-meta__tags" href="/tags/react/">react</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img"><div class="post-qr-code__desc">暂时无</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/03/10/next/"><i class="fa fa-chevron-left">  </i><span>next</span></a></div><div class="next-post pull-right"><a href="/2023/03/10/react_api/"><span>React Api</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://autoload.github.io/css/images/banner_sky.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2023 By sunshine</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>